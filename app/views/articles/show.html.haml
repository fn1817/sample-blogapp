.article#article-show{ data: { article_id: @article.id } }
  -# attached?:画像がアップロードされているかどうか判定
  -# .eyecatchは空の枠のようなオブジェクトが存在する状態なので、nilにはならない=ぼっち演算子を使わなくてOK（エラーにならない）
  - if @article.eyecatch.attached?
    .article_image
      = image_tag @article.eyecatch
  %h1.article_title= @article.title
  .article_detail
    -# この記事を作成したユーザ情報のページに飛ぶ（@article.userでuser_idを自動で取得）（accounts#showを実行）
    = link_to account_path(@article.user) do
      -# avatar_imageメソッドの呼び出し
      = image_tag @article.user.avatar_image
    %div
      -# - if @article.user.present?（記事を書いたユーザが存在していれば実行（アカウント名を表示））を削除
      -# .user = Railsが自動でこの記事を書いたユーザを返す
      %p= @article.author_name
      %p= @article.display_created_at
    - if user_signed_in? && current_user.has_written?(@article)
      -# ログインしている&ログインユーザがこの記事を書いていれば実行（編集・削除ボタンを表示）
      .article_detail_actions
        .dropdown
          = image_tag 'actions.svg', class: 'dropbtn'
          .dropdown-content.mini
            = link_to '編集する', edit_article_path(@article)
            = link_to '削除する', article_path(@article), data: { turbo_method: 'delete', turbo_confirm: '本当に削除してもよろしいですか？' }
  .article_content
    = @article.content
  -# ログインしていないと「いいね」できないようにする
  - if user_signed_in?
    .article_heart.hidden.active-heart
      = image_tag 'heart-active.svg'
    .article_heart.hidden.inactive-heart
      = image_tag 'heart.svg'

-# コメント一覧の表示
.article
  %h2 コメント一覧
  .comments-container

.container
  -# フォームを表示するためのボタン
  .btn-secondary.show-comment-form
    コメントを追加
  -# フォームを表示するためのボタンを押すまで非表示
  .comment-text-area.hidden
    -# text_area_tag = textareaを表示するためのhelperメソッド（Railsで用意されている）
    -# :comment_content = パラメータ名, '' = 初期値
    = text_area_tag :comment_content, '', class: 'sm'
    -# コメントを追加するためのボタン
    .btn-secondary.add-comment-button
      コメントを追加

%script{ type: "module" }
  import "packs/article.js"